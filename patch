diff --git a/components/fineoffset/__init__.py b/components/fineoffset/__init__.py
index d0a56b8..a54e714 100644
--- a/components/fineoffset/__init__.py
+++ b/components/fineoffset/__init__.py
@@ -10,6 +10,7 @@ MULTI_CONF = True
 AUTO_LOAD = ["sensor"]
 
 CONF_FINEOFFSET_ID = "fineoffset_id"
+CONF_TIMING_ANALYSIS = "timing_analysis"
 
 fineoffset_ns = cg.esphome_ns.namespace("fineoffset")
 FineOffset = fineoffset_ns.class_("FineOffsetComponent", cg.Component)
@@ -20,6 +21,7 @@ CONFIG_SCHEMA = cv.All(
             cv.GenerateID(): cv.declare_id(FineOffset),
             cv.Required(CONF_PIN): pins.internal_gpio_input_pin_schema,
             cv.Optional(CONF_NAME): cv.string,
+            cv.Optional(CONF_TIMING_ANALYSIS, default=False): cv.boolean,
         }
     ).extend(cv.polling_component_schema("60s")),
 )
@@ -36,3 +38,4 @@ async def to_code(config):
 
     pin = await cg.gpio_pin_expression(config[CONF_PIN])
     cg.add(var.set_pin(pin))
+    cg.add(var.enable_timing_analysis(config[CONF_TIMING_ANALYSIS]))
diff --git a/components/fineoffset/fineoffset.cpp b/components/fineoffset/fineoffset.cpp
index 79a281d..f9bd44f 100644
--- a/components/fineoffset/fineoffset.cpp
+++ b/components/fineoffset/fineoffset.cpp
@@ -13,6 +13,13 @@
 #include <cstddef>
 #include <cstdint>
 
+#ifdef ESP_IDF_VERSION
+#include "esp_timer.h"
+#define GET_TIMESTAMP() esp_timer_get_time()
+#else
+#define GET_TIMESTAMP() micros()
+#endif
+
 namespace esphome {
 namespace fineoffset {
 
@@ -51,36 +58,40 @@ std::string FineOffsetState::str() const {
     return data;
 }
 
-//--------------------------------------------------------
-// 1 is indicated by 500uS pulse
-// wh2_accept from 2 = 400us to 3 = 600us
-#define IS_HI_PULSE(interval) (interval >= 250 && interval <= 750)
-// 0 is indicated by ~1500us pulse
-// wh2_accept from 7 = 1400us to 8 = 1600us
-#define IS_LOW_PULSE(interval) (interval >= 1200 && interval <= 1750)
-// worst case packet length
-// 6 bytes x 8 bits =48
-#define IDLE_HAS_TIMED_OUT(interval) (interval > 1199)
-// our expected pulse should arrive after 1ms
-// we'll wh2_accept it if it arrives after
-// 4 x 200us = 800us
-#define IDLE_PERIOD_DONE(interval) (interval >= 751)
-
-// const auto GOT_PULSE = 0x01;
-// const auto LOGIC_HI = 0x02;
-#define GOT_PULSE 0x01
-#define LOGIC_HI 0x02
+const byte FLAG_VALID_PULSE = 0x01;
+const byte FLAG_BIT_VALUE_ONE = 0x02;
+
+const uint32_t one_bit_pulse_min_{400};  // '1' bit: 500μs nominal
+const uint32_t one_bit_pulse_max_{600};
+const uint32_t zero_bit_pulse_min_{1300};  // '0' bit: 1500μs nominal
+const uint32_t zero_bit_pulse_max_{1700};
+
+const uint32_t idle_timeout_{2000};
+const uint32_t idle_period_done_{800};
+const uint32_t min_pulse_width_{200};
+
+static bool is_one_bit_pulse(const uint32_t interval) {
+    return interval >= one_bit_pulse_min_ && interval <= one_bit_pulse_max_;
+}
+static bool is_zero_bit_pulse(const uint32_t interval) {
+    return interval >= zero_bit_pulse_min_ && interval <= zero_bit_pulse_max_;
+}
+static bool has_idle_timed_out(const uint32_t interval) { return interval > idle_timeout_; }
+static bool is_idle_period_done(const uint32_t interval) { return interval >= idle_period_done_; }
 
 FineOffsetStore::FineOffsetStore(FineOffsetComponent* parent)
     : parent_(parent), state_obj_(nullptr), wh2_flags_{0}, packet_state_{0} {}
 
 void IRAM_ATTR FineOffsetStore::intr_cb(FineOffsetStore* self) {
-    static unsigned long edgeTimeStamp[3] = {0};  // Timestamp of edges
+    static uint64_t edgeTimeStamp[3] = {0};  // Timestamp of edges
     static bool skip = true;
 
+    // Use ESP32-specific high-resolution timer
+    const uint64_t now = GET_TIMESTAMP();  // Use esp_timer_get_time() on ESP-IDF
+
     // Filter out too short pulses. This method works as a low pass filter.  (borroved from new remote reciever)
     edgeTimeStamp[1] = edgeTimeStamp[2];
-    edgeTimeStamp[2] = micros();
+    edgeTimeStamp[2] = now;
 
     if (skip) {
         skip = false;
@@ -94,9 +105,14 @@ void IRAM_ATTR FineOffsetStore::intr_cb(FineOffsetStore* self) {
         return;
     }
 
-    unsigned int pulse = edgeTimeStamp[1] - edgeTimeStamp[0];
+    // Calculate pulse width - note: still safe to cast to uint32_t for pulse timing
+    // since pulses are only a few milliseconds at most
+    uint32_t pulse = (uint32_t) (edgeTimeStamp[1] - edgeTimeStamp[0]);
     edgeTimeStamp[0] = edgeTimeStamp[1];
 
+    // Record for analysis
+    self->timing_analyzer_.record_pulse(pulse);
+
     static byte wh2_flags = 0x00;
     static bool wh2_accept_flag = false;
     static byte wh2_packet_state = 0;
@@ -111,20 +127,20 @@ void IRAM_ATTR FineOffsetStore::intr_cb(FineOffsetStore* self) {
     switch (sampling_state) {
         case 0:  // waiting
 
-            if (IS_HI_PULSE(pulse)) {
-                wh2_flags = GOT_PULSE | LOGIC_HI;
+            if (is_one_bit_pulse(pulse)) {
+                wh2_flags = FLAG_VALID_PULSE | FLAG_BIT_VALUE_ONE;
                 sampling_state = 1;
-            } else if (IS_LOW_PULSE(pulse)) {
-                wh2_flags = GOT_PULSE;  // logic low
+            } else if (is_zero_bit_pulse(pulse)) {
+                wh2_flags = FLAG_VALID_PULSE;  // Zeor bit (FLAG_BIT_VALUE_ONE not set)
             } else {
                 sampling_state = 0;
             }
             break;
         case 1:  // observe 1ms of idle time
-            if (IDLE_HAS_TIMED_OUT(pulse)) {
+            if (has_idle_timed_out(pulse)) {
                 sampling_state = 0;
                 wh2_packet_state = 1;
-            } else if (IDLE_PERIOD_DONE(pulse)) {
+            } else if (is_idle_period_done(pulse)) {
                 sampling_state = 0;
             } else {
                 sampling_state = 0;
@@ -139,7 +155,7 @@ void IRAM_ATTR FineOffsetStore::intr_cb(FineOffsetStore* self) {
             // shift history right and store new value
             history <<= 1;
             // store a 1 if required (right shift along will store a 0)
-            if (wh2_flags & LOGIC_HI) {
+            if (wh2_flags & FLAG_BIT_VALUE_ONE) {
                 history |= 0x01;
             }
 
@@ -161,7 +177,7 @@ void IRAM_ATTR FineOffsetStore::intr_cb(FineOffsetStore* self) {
         // acquire packet
         else if (wh2_packet_state == 2) {
             wh2_packet[packet_no] <<= 1;
-            if (wh2_flags & LOGIC_HI) {
+            if (wh2_flags & FLAG_BIT_VALUE_ONE) {
                 wh2_packet[packet_no] |= 0x01;
             }
             bit_no++;
@@ -182,12 +198,12 @@ void IRAM_ATTR FineOffsetStore::intr_cb(FineOffsetStore* self) {
 
         if (wh2_accept_flag) {
             uint8_t crc = FineOffsetState::crc8ish(wh2_packet, 4);
-            self->cycles_++;
+            self->cycles_ += 1;
 
             if (crc == wh2_packet[4]) {
                 wh2_valid = true;
             } else {
-                self->bad_count_++;
+                self->bad_count_ += 1;
                 wh2_valid = false;
             }
 
@@ -343,4 +359,4 @@ void FineOffsetComponent::register_text_sensor(FineOffsetTextSensor* obj) {
 }
 
 }  // namespace fineoffset
-}  // namespace esphome
\ No newline at end of file
+}  // namespace esphome
diff --git a/components/fineoffset/fineoffset.h b/components/fineoffset/fineoffset.h
index fff9e3f..3298eb3 100644
--- a/components/fineoffset/fineoffset.h
+++ b/components/fineoffset/fineoffset.h
@@ -12,6 +12,8 @@
 #include "esphome/core/defines.h"
 #include "esphome/core/gpio.h"
 
+#include "timing_analyzer.h"
+
 namespace esphome {
 class InternalGPIOPin;
 namespace fineoffset {
@@ -80,6 +82,9 @@ class FineOffsetStore {
         this->last_unknown_.reset();
     }
 
+    void enable_timing_analysis(bool enable) { this->timing_analyzer_.enable(enable); }
+    void log_timing_analysis() const { this->timing_analyzer_.log_analysis("fineoffset.timing"); }
+
     static void intr_cb(FineOffsetStore* arg);
 
    protected:
@@ -105,6 +110,8 @@ class FineOffsetStore {
 
     std::shared_ptr<FineOffsetState> last_bad_{nullptr};
     std::shared_ptr<FineOffsetState> last_unknown_{nullptr};
+
+    TimingAnalyzer timing_analyzer_{400, 600, 1300, 1700};  // TODO: replace w/ constants
 };
 
 class FineOffsetSensor;
@@ -115,6 +122,7 @@ class FineOffsetComponent : public PollingComponent {
     FineOffsetComponent() : store_(this) {}
 
     void set_pin(InternalGPIOPin* pin) { pin_ = pin; }
+    void enable_timing_analysis(bool enable) { store_.enable_timing_analysis(enable); }
     void setup() override {
         PollingComponent::setup();
         this->store_.setup(this->pin_);
@@ -130,10 +138,11 @@ class FineOffsetComponent : public PollingComponent {
    protected:
     FineOffsetStore store_;
     InternalGPIOPin* pin_;
+    bool timing_analysis_enabled_{false};
 
     std::map<uint32_t, FineOffsetSensor*> sensors_;
     std::vector<FineOffsetTextSensor*> text_sensors_;
 };
 
 }  // namespace fineoffset
-}  // namespace esphome
\ No newline at end of file
+}  // namespace esphome
diff --git a/components/fineoffset/sensor/wh2_sensor.h b/components/fineoffset/sensor/wh2_sensor.h
deleted file mode 100644
index e0b05af..0000000
--- a/components/fineoffset/sensor/wh2_sensor.h
+++ /dev/null
@@ -1,364 +0,0 @@
-#pragma once
-#if 0
-
-volatile byte have_data_string = 0;
-volatile int have_data_sensor = 0;
-volatile int temp;
-volatile int hum;
-volatile unsigned int cycles = 0;
-volatile int str_Sensor_ID;
-volatile int str_humidity;
-volatile int str_temperature;
-volatile unsigned int str_cycles = 0;
-volatile bool str_wh2_valid;
-
-static void ICACHE_RAM_ATTR ext_int_1() {
-    static unsigned long edgeTimeStamp[3] = { 0, }; // Timestamp of edges
-    static bool skip = true;
-
-    // Filter out too short pulses. This method works as a low pass filter.  (borroved from new remote reciever)
-    edgeTimeStamp[1] = edgeTimeStamp[2];
-    edgeTimeStamp[2] = micros();
-
-    if (skip) {
-        skip = false;
-        return;
-    }
-
-    if (edgeTimeStamp[2] - edgeTimeStamp[1] < 200) {
-        // Last edge was too short.
-        // Skip this edge, and the next too.
-        skip = true;
-        return;
-    }
-
-    unsigned int pulse = edgeTimeStamp[1] - edgeTimeStamp[0];
-    edgeTimeStamp[0] = edgeTimeStamp[1];
-
-    //--------------------------------------------------------
-    // 1 is indicated by 500uS pulse
-    // wh2_accept from 2 = 400us to 3 = 600us
-    #define IS_HI_PULSE(interval)(interval >= 250 && interval <= 750)
-    // 0 is indicated by ~1500us pulse
-    // wh2_accept from 7 = 1400us to 8 = 1600us
-    #define IS_LOW_PULSE(interval)(interval >= 1200 && interval <= 1750)
-    // worst case packet length
-    // 6 bytes x 8 bits =48
-    #define IDLE_HAS_TIMED_OUT(interval)(interval > 1199)
-    // our expected pulse should arrive after 1ms
-    // we'll wh2_accept it if it arrives after
-    // 4 x 200us = 800us
-    #define IDLE_PERIOD_DONE(interval)(interval >= 751)
-    #define GOT_PULSE 0x01
-    #define LOGIC_HI 0x02
-
-    static byte wh2_flags = 0x00;
-    static bool wh2_accept_flag = false;
-    static byte wh2_packet_state = 0;
-    static byte wh2_packet[5] = {0,};
-    static bool wh2_valid = false;
-    static byte sampling_state = 0;
-    static byte packet_no = 0;
-    static byte bit_no = 0;
-    static byte history = 0x01;
-
-    switch (sampling_state) {
-    case 0: // waiting
-
-        if (IS_HI_PULSE(pulse)) {
-            wh2_flags = GOT_PULSE | LOGIC_HI;
-            sampling_state = 1;
-        } 
-        else if (IS_LOW_PULSE(pulse)) {
-            wh2_flags = GOT_PULSE; // logic low
-        }
-        else {
-            sampling_state = 0;
-        }
-        break;
-    case 1: // observe 1ms of idle time
-
-        if (IDLE_HAS_TIMED_OUT(pulse)) {
-            sampling_state = 0;
-            wh2_packet_state = 1;
-        }
-        else if (IDLE_PERIOD_DONE(pulse)) {
-            sampling_state = 0;
-        }
-        else {
-            sampling_state = 0;
-            wh2_packet_state = 1;
-        }
-        break;
-    }
-
-    if (wh2_flags) {
-
-        // acquire preamble
-        if (wh2_packet_state == 1) {
-            // shift history right and store new value
-            history <<= 1;
-            // store a 1 if required (right shift along will store a 0)
-            if (wh2_flags & LOGIC_HI) {
-                history |= 0x01;
-            }
-
-            // check if we have a valid start of frame
-            // xxxxx110
-            if ((history & B00000111) == B00000110) {
-                // need to clear packet, and pulseers
-                packet_no = 0;
-                // start at 1 becuase only need to acquire 7 bits for first packet byte.
-                bit_no = 1;
-                wh2_packet[0] = wh2_packet[1] = wh2_packet[2] = wh2_packet[3] = wh2_packet[4] = 0;
-                // we've acquired the preamble
-                wh2_packet_state = 2;
-                history = 0xFF;
-            }
-            wh2_accept_flag = false;
-        }
-        // acquire packet
-        else if (wh2_packet_state == 2) {
-            wh2_packet[packet_no] <<= 1;
-            if (wh2_flags & LOGIC_HI) {
-                wh2_packet[packet_no] |= 0x01;
-            }
-            bit_no++;
-            if (bit_no > 7) {
-                bit_no = 0;
-                packet_no++;
-            }
-            if (packet_no > 4) {
-                // start the sampling process from scratch
-                wh2_packet_state = 1;
-                wh2_accept_flag = true;
-            }
-        }
-        else {
-            wh2_accept_flag = false;
-        }
-
-        if (wh2_accept_flag) {
-            int Sensor_ID = ((wh2_packet[0]&0x0F) << 4) + ((wh2_packet[1]&0xF0) >> 4);
-            int humidity = wh2_packet[3];
-            int temperature = ((wh2_packet[1] & B00000111) << 8) + wh2_packet[2];
-            // make negative
-            if (wh2_packet[1] & B00001000) {
-                temperature = -temperature;
-            }
-            uint8_t crc = 0;
-            uint8_t len = 4;
-            uint8_t addr = 0;
-            // Indicated changes are from reference CRC-8 function in OneWire library
-            while (len--) {
-                uint8_t inbyte = wh2_packet[addr++];
-                for (uint8_t i = 8; i; i--) {
-                    uint8_t mix = (crc ^ inbyte) & 0x80; // changed from & 0x01
-                    crc <<= 1; // changed from right shift
-                    if (mix) crc ^= 0x31; // changed from 0x8C;
-                    inbyte <<= 1; // changed from right shift
-                }
-            }
-            if (crc == wh2_packet[4]) {
-                wh2_valid = true;
-            }
-            else {
-                wh2_valid = false;
-            }
-
-            extern volatile int have_data_sensor;
-            // avoid change sensor data during update
-            if (wh2_valid == true && have_data_sensor == 0) {
-                extern volatile int temp;
-                extern volatile int hum;
-                extern volatile unsigned int cycles;
-                temp = temperature;
-                hum = humidity;
-                cycles = cycles + 1;
-                have_data_sensor = Sensor_ID;
-            }
-
-            extern volatile byte have_data_string;
-            // avoid change sensor data during update
-            if (have_data_string == 0) {
-                str_Sensor_ID = Sensor_ID;
-                str_humidity = humidity;
-                str_temperature = temperature;
-                str_cycles = cycles;
-                str_wh2_valid = wh2_valid;
-                have_data_string = 1;
-            }
-
-            wh2_accept_flag = false;
-        }
-        wh2_flags = 0x00;
-    }
-    //--------------------------------------------------------
-
-}
-
-class WH2Sensor : public PollingComponent {
-public:
-    Sensor *sensor1 = new Sensor();
-    Sensor *sensor2 = new Sensor();
-    Sensor *sensor3 = new Sensor();
-
-    WH2Sensor() : PollingComponent(1000) {
-        ESP_LOGD("custom", "WH2Sensor::WH2Sensor()");
-    }
-
-    float get_setup_priority() const override {
-        return esphome::setup_priority::DATA;
-    }
-
-    void setup() override {
-        //For ESP8266,if you are using rx pin for reciever set to 3 below
-        //For Sonoff Bridge with direct HW patch use pin 4
-        ESP_LOGD("custom", "WH2Sensor.setup()");
-        //Serial.end();
-        attachInterrupt(33, ext_int_1, CHANGE);
-    }
-ext_int_1
-    void update() override {
-        // This is the actual sensor reading logic.
-        extern volatile int have_data_sensor;
-        extern volatile int temp;
-        extern volatile int hum;
-        extern volatile unsigned int cycles;
-
-        if (have_data_sensor != 0) {
-            ESP_LOGD("custom", "have_data_sensor: %d, temp: %d, hum: %d, cycles: %u",
-                        have_data_sensor, temp, hum, cycles);
-        }
-        if (have_data_sensor == 77 || have_data_sensor == 1122) {
-            sensor1->publish_state(temp * 0.1f);
-            sensor2->publish_state(float(hum));
-            sensor3->publish_state(cycles);
-            have_data_sensor = 0;
-        } else if (have_data_sensor) {
-            have_data_sensor = 0;
-        }
-    }
-protected:
-    ISRInternalGPIOPin pin_;
-};
-
-class WH2LastSensorData : public PollingComponent, public TextSensor {
-public:
-
-    // constructor
-    WH2LastSensorData() : PollingComponent(1000) {
-        ESP_LOGD("custom", "WH2LastSensorData()");
-        sensor_data_.reserve(100);
-    }
-
-    float get_setup_priority() const override {
-        return esphome::setup_priority::DATA;
-    }
-
-    void setup() override {
-        // This will be called by App.setup()
-        ESP_LOGD("custom", "WH2LastSensorData.setup()");
-    }
-
-    void update() override {
-        extern volatile byte have_data_string;
-        extern volatile int str_Sensor_ID;
-        extern volatile int str_humidity;
-        extern volatile int str_temperature;
-        extern volatile unsigned int str_cycles;
-        extern volatile bool str_wh2_valid;
-
-        // This will be called every "update_interval" milliseconds.
-        if (have_data_string == 1) {
-            if (str_wh2_valid) {
-                char temperture_buf[7] = {0, }; // 7 bytes is enough for -100.0 with a '\0'
-
-                snprintf(temperture_buf, sizeof(temperture_buf), "%.1f", (str_temperature * 0.1f));
-                sensor_data_.clear();
-                sensor_data_ += "| Sensor ID:  ";
-                sensor_data_ += to_string(str_Sensor_ID);
-                sensor_data_ += " | humidity: ";
-                sensor_data_ += to_string(str_humidity);
-                sensor_data_ += "% | temperature: ";
-                sensor_data_ += to_string(temperture_buf);
-                sensor_data_ += "°C | ";
-                sensor_data_ += to_string(str_wh2_valid ? "OK " : "BAD");
-                // "cycles: ";
-                // my_data += to_string(str_cycles);
-                // my_data += "| ";
-
-                // Publish state
-                publish_state(sensor_data_);
-                have_data_string = 0;
-            }
-            else if (!str_wh2_valid) {
-                ESP_LOGD("custom", "BAD skipped");
-            }
-        }
-    }
-
-protected:
-    std::string sensor_data_;
-};
-
-class WH2BadSensorData : public PollingComponent, public TextSensor {
-public:
-
-    // constructor
-    WH2BadSensorData() : PollingComponent(1000) {
-        ESP_LOGD("custom", "WH2BadSensorData()");
-        sensor_data_.reserve(100);
-    }
-
-    float get_setup_priority() const override {
-        return esphome::setup_priority::DATA;
-    }
-
-    void setup() override {
-        // This will be called by App.setup()
-        ESP_LOGD("custom", "WH2BadSensorData.setup()");
-    }
-
-    // This will be called every "update_interval" milliseconds.
-    void update() override {
-        extern volatile byte have_data_string;
-        extern volatile int str_Sensor_ID;
-        extern volatile int str_humidity;
-        extern volatile int str_temperature;
-        extern volatile unsigned int str_cycles;
-        extern volatile bool str_wh2_valid;
-
-        if (have_data_string == 1) {
-            if (!str_wh2_valid) {
-                char temperture_buf[7] = {0, }; // 7 bytes is enough for -100.0 with a '\0'
-
-                snprintf(temperture_buf, sizeof(temperture_buf), "%.1f", (str_temperature * 0.1f));
-                sensor_data_.clear();
-                sensor_data_ += "| Sensor ID:  ";
-                sensor_data_ += to_string(str_Sensor_ID);
-                sensor_data_ += " | humidity: ";
-                sensor_data_ += to_string(str_humidity);
-                sensor_data_ += "% | temperature: ";
-                sensor_data_ += to_string(temperture_buf);
-                sensor_data_ += "°C | ";
-                sensor_data_ += to_string(str_wh2_valid ? "OK " : "BAD");
-                // "cycles: ";
-                // my_data += to_string(str_cycles);
-                // my_data += "| ";
-
-                // Publish state
-                publish_state(sensor_data_);
-                have_data_string = 0;
-            }
-            else if (str_wh2_valid) {
-                ESP_LOGD("custom", "OK skipped");
-            }
-        }
-    }
-
-protected:
-    std::string sensor_data_;
-};
-
-#endif
diff --git a/components/fineoffset/timing_analyzer.h b/components/fineoffset/timing_analyzer.h
new file mode 100644
index 0000000..52f435a
--- /dev/null
+++ b/components/fineoffset/timing_analyzer.h
@@ -0,0 +1,182 @@
+// timing_analyzer.h
+#pragma once
+
+#include <cstdint>
+#include <cstring>
+
+#include "esphome/core/log.h"
+
+namespace esphome {
+namespace fineoffset {
+
+class TimingAnalyzer {
+   public:
+    struct PulseStats {
+        uint32_t count{0};
+        uint32_t sum{0};
+        uint32_t min_value{UINT32_MAX};
+        uint32_t max_value{0};
+
+        uint32_t average() const { return count > 0 ? sum / count : 0; }
+        uint32_t range() const { return max_value > min_value ? max_value - min_value : 0; }
+
+        void update(uint32_t value) {
+            count++;
+            sum += value;
+            min_value = std::min(min_value, value);
+            max_value = std::max(max_value, value);
+        }
+
+        void reset() {
+            count = 0;
+            sum = 0;
+            min_value = UINT32_MAX;
+            max_value = 0;
+        }
+    };
+
+    struct ThresholdSuggestion {
+        uint32_t min_threshold;
+        uint32_t max_threshold;
+        bool valid;
+    };
+
+   private:
+    static constexpr size_t SAMPLE_BUFFER_SIZE = 1000;
+    static constexpr uint32_t MIN_SAMPLES_FOR_ANALYSIS = 10;
+    static constexpr uint32_t SAFETY_MARGIN_US = 50;
+
+    bool enabled_{false};
+    uint32_t pulse_samples_[SAMPLE_BUFFER_SIZE];
+    uint16_t sample_index_{0};
+
+    PulseStats short_pulse_stats_;  // '1' bits
+    PulseStats long_pulse_stats_;   // '0' bits
+    uint32_t rejected_count_{0};
+
+    // Current thresholds for classification
+    uint32_t short_pulse_min_;
+    uint32_t short_pulse_max_;
+    uint32_t long_pulse_min_;
+    uint32_t long_pulse_max_;
+
+   public:
+    TimingAnalyzer(uint32_t short_min, uint32_t short_max, uint32_t long_min, uint32_t long_max)
+        : short_pulse_min_(short_min),
+          short_pulse_max_(short_max),
+          long_pulse_min_(long_min),
+          long_pulse_max_(long_max) {}
+
+    void enable(bool enable = true) {
+        enabled_ = enable;
+        if (enable) {
+            reset();
+        }
+    }
+
+    bool is_enabled() const { return enabled_; }
+
+    void reset() {
+        sample_index_ = 0;
+        short_pulse_stats_.reset();
+        long_pulse_stats_.reset();
+        rejected_count_ = 0;
+        memset(pulse_samples_, 0, sizeof(pulse_samples_));
+    }
+
+    void record_pulse(uint32_t pulse_width) {
+        if (!enabled_)
+            return;
+
+        // Store in circular buffer
+        pulse_samples_[sample_index_] = pulse_width;
+        sample_index_ = (sample_index_ + 1) % SAMPLE_BUFFER_SIZE;
+
+        // Classify and update stats
+        if (is_short_pulse(pulse_width)) {
+            short_pulse_stats_.update(pulse_width);
+        } else if (is_long_pulse(pulse_width)) {
+            long_pulse_stats_.update(pulse_width);
+        } else {
+            rejected_count_++;
+        }
+    }
+
+    ThresholdSuggestion suggest_short_pulse_thresholds() const {
+        if (short_pulse_stats_.count < MIN_SAMPLES_FOR_ANALYSIS) {
+            return {0, 0, false};
+        }
+
+        uint32_t avg = short_pulse_stats_.average();
+        uint32_t tolerance = (short_pulse_stats_.range() / 2) + SAFETY_MARGIN_US;
+
+        return {
+            .min_threshold = avg > tolerance ? avg - tolerance : 0, .max_threshold = avg + tolerance, .valid = true};
+    }
+
+    ThresholdSuggestion suggest_long_pulse_thresholds() const {
+        if (long_pulse_stats_.count < MIN_SAMPLES_FOR_ANALYSIS) {
+            return {0, 0, false};
+        }
+
+        uint32_t avg = long_pulse_stats_.average();
+        uint32_t tolerance = (long_pulse_stats_.range() / 2) + SAFETY_MARGIN_US;
+
+        return {
+            .min_threshold = avg > tolerance ? avg - tolerance : 0, .max_threshold = avg + tolerance, .valid = true};
+    }
+
+    void log_analysis(const char* tag = "timing_analyzer") const {
+        if (!enabled_) {
+            ESP_LOGW(tag, "Timing analysis not enabled");
+            return;
+        }
+
+        ESP_LOGI(tag, "=== Timing Analysis Results ===");
+
+        // Short pulse analysis
+        if (short_pulse_stats_.count > 0) {
+            ESP_LOGI(tag, "Short pulses ('1' bits): count=%u, avg=%uμs, range=%u-%uμs", short_pulse_stats_.count,
+                     short_pulse_stats_.average(), short_pulse_stats_.min_value, short_pulse_stats_.max_value);
+
+            auto suggestion = suggest_short_pulse_thresholds();
+            if (suggestion.valid) {
+                ESP_LOGI(tag, "  Suggested range: %u-%uμs (current: %u-%uμs)", suggestion.min_threshold,
+                         suggestion.max_threshold, short_pulse_min_, short_pulse_max_);
+            }
+        }
+
+        // Long pulse analysis
+        if (long_pulse_stats_.count > 0) {
+            ESP_LOGI(tag, "Long pulses ('0' bits): count=%u, avg=%uμs, range=%u-%uμs", long_pulse_stats_.count,
+                     long_pulse_stats_.average(), long_pulse_stats_.min_value, long_pulse_stats_.max_value);
+
+            auto suggestion = suggest_long_pulse_thresholds();
+            if (suggestion.valid) {
+                ESP_LOGI(tag, "  Suggested range: %u-%uμs (current: %u-%uμs)", suggestion.min_threshold,
+                         suggestion.max_threshold, long_pulse_min_, long_pulse_max_);
+            }
+        }
+
+        ESP_LOGI(tag, "Rejected pulses: %u", rejected_count_);
+        ESP_LOGI(tag, "Total samples collected: %u",
+                 std::min(sample_index_, static_cast<uint16_t>(SAMPLE_BUFFER_SIZE)));
+    }
+
+    // Getters for current stats
+    const PulseStats& get_short_pulse_stats() const { return short_pulse_stats_; }
+    const PulseStats& get_long_pulse_stats() const { return long_pulse_stats_; }
+    uint32_t get_rejected_count() const { return rejected_count_; }
+
+   private:
+    bool is_short_pulse(uint32_t pulse_width) const {
+        return pulse_width >= short_pulse_min_ && pulse_width <= short_pulse_max_;
+    }
+
+    bool is_long_pulse(uint32_t pulse_width) const {
+        return pulse_width >= long_pulse_min_ && pulse_width <= long_pulse_max_;
+    }
+};
+
+}  // namespace fineoffset
+}  // namespace esphome
diff --git a/example.yaml b/example.yaml
index a2fbc1a..096f541 100644
--- a/example.yaml
+++ b/example.yaml
@@ -15,6 +15,7 @@ fineoffset:
   - name: FineOffset Radio
     id: fineoffset_radio
     pin: GPIO33
+    timing_analysis: true
 
 sensor:
   - platform: fineoffset
